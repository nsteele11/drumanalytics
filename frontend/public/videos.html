<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Videos</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/style.css">
</head>
<body>

<nav>
    <a href="index.html">Instagram Insights</a>
    <a href="prerecording.html">Pre Recording</a>
    <a href="upload.html">Video Upload</a>
    <a href="videos.html" class="active">Videos</a>
    <a href="audio.html">Audio Analytics</a>
</nav>

<main>
    <h1>Videos</h1>

    <div class="section-placeholder">
        <div id="loading" style="text-align: center; padding: 20px; display: none;">
            Loading videos...
        </div>
        
        <div id="error" style="display: none; padding: 15px; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 5px; color: #721c24; margin-bottom: 20px;">
        </div>

        <div id="videosContainer" class="videos-container">
            <!-- Videos will be inserted here -->
        </div>
    </div>
</main>

<script>
// Fetch and display videos
async function loadVideos() {
    const loadingDiv = document.getElementById('loading');
    const errorDiv = document.getElementById('error');
    const videosContainer = document.getElementById('videosContainer');

    loadingDiv.style.display = 'block';
    errorDiv.style.display = 'none';
    videosContainer.innerHTML = '';

    try {
        const response = await fetch('/api/videos');
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const videos = await response.json();
        loadingDiv.style.display = 'none';

        if (videos.length === 0) {
            videosContainer.innerHTML = '<p style="text-align: center; padding: 40px; color: #666;">No videos uploaded yet.</p>';
            return;
        }

        // Store videos for shock value color calculation
        allVideosForShockValue = videos;
        
        // Display videos
        videos.forEach(video => {
            const videoCard = createVideoCard(video);
            videosContainer.appendChild(videoCard);
        });

    } catch (err) {
        loadingDiv.style.display = 'none';
        errorDiv.style.display = 'block';
        errorDiv.textContent = `Error loading videos: ${err.message}`;
        console.error('Error loading videos:', err);
    }
}

function createVideoCard(video) {
    const card = document.createElement('div');
    card.className = 'video-card';

    // Album cover or placeholder
    const albumCover = video.albumImageUrl 
        ? `<img src="${video.albumImageUrl}" alt="Album Cover" class="video-album-cover">`
        : '<div class="video-album-placeholder">No Cover</div>';

    // Video snapshot (will be loaded asynchronously)
    const videoSnapshot = video.snapshotKey
        ? `<img src="" alt="Video Snapshot" class="video-snapshot" data-snapshot-key="${escapeHtml(video.snapshotKey)}" style="display: none;">`
        : '';

    card.innerHTML = `
        <div class="video-card-content">
            <button class="delete-video-btn-x" data-s3key="${escapeHtml(video.s3Key)}" title="Delete video">
                √ó
            </button>
            <div class="video-album-section">
                ${albumCover}
                ${videoSnapshot}
            </div>
            <div class="video-info-section">
                <h3 class="video-track-name">${escapeHtml(video.trackName)}</h3>
                <p class="video-artist-name">${escapeHtml(video.artistName)}</p>
                
                <div class="video-metadata">
                    ${video.album ? `<div class="video-meta-item"><strong>Album:</strong> ${escapeHtml(video.album)}</div>` : ''}
                    ${video.popularity !== null ? `<div class="video-meta-item"><strong>Popularity:</strong> ${video.popularity}/100</div>` : ''}
                    ${video.artistFollowers !== null ? `<div class="video-meta-item"><strong>Artist Followers:</strong> ${video.artistFollowers.toLocaleString()}</div>` : ''}
                    ${video.genres && video.genres.length > 0 ? `<div class="video-meta-item"><strong>Genres:</strong> ${escapeHtml(video.genres.join(', '))}</div>` : ''}
                    ${video.duration ? `<div class="video-meta-item"><strong>Duration:</strong> ${formatDuration(video.duration)}</div>` : ''}
                    ${video.bpm ? `<div class="video-meta-item"><strong>BPM:</strong> ${video.bpm}</div>` : ''}
                    ${video.shockValue !== null ? `
                        <div class="video-meta-item">
                            <strong>Shock Value:</strong> 
                            <span class="hoverable-score-container" style="position: relative; display: inline-block;">
                                <span class="clickable-score" style="font-weight: bold; color: ${getShockValueColorWithTop20(video.shockValue, allVideosForShockValue)}; cursor: pointer; text-decoration: underline;" 
                                      onmouseenter="showShockValueDropdown('shock-${video.s3Key}', ${video.shockValue}, ${video.tempoSpikes !== null ? video.tempoSpikes : 'null'}, ${video.volumeSpikes !== null ? video.volumeSpikes : 'null'}, ${video.unusualPatterns !== null ? video.unusualPatterns : 'null'})"
                                      onmouseleave="hideShockValueDropdown('shock-${video.s3Key}')">
                                    ${video.shockValue}/100
                                </span>
                                <div id="shock-dropdown-shock-${video.s3Key}" class="score-dropdown" 
                                     style="display: none; background: white; border: 1px solid #ced4da; border-radius: 4px; padding: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); z-index: 100000; min-width: 280px; font-size: 12px;"
                                     onmouseenter="clearScoreDropdownTimeout()"
                                     onmouseleave="hideShockValueDropdown('shock-${video.s3Key}')"></div>
                            </span>
                        </div>
                    ` : ''}
                    ${video.successScore !== null && video.successScore !== undefined ? `
                        <div class="video-meta-item">
                            <strong>Video Success Score:</strong> 
                            <span class="hoverable-score-container" style="position: relative; display: inline-block;">
                                <span class="clickable-score" style="font-weight: bold; color: ${getSuccessScoreColor(video.successScore)}; cursor: pointer; text-decoration: underline;" 
                                      onmouseenter="showSuccessScoreDropdown('success-${video.s3Key}', ${video.igViews || 0}, ${video.igLikes || 0}, ${video.tiktokViews || 0}, ${video.tiktokLikes || 0}, ${video.successScore})"
                                      onmouseleave="hideSuccessScoreDropdown('success-${video.s3Key}')">
                                    ${video.successScore}/100
                                </span>
                                <div id="success-dropdown-success-${video.s3Key}" class="score-dropdown" 
                                     style="display: none; background: white; border: 1px solid #ced4da; border-radius: 4px; padding: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); z-index: 100000; min-width: 320px; font-size: 12px;"
                                     onmouseenter="clearScoreDropdownTimeout()"
                                     onmouseleave="hideSuccessScoreDropdown('success-${video.s3Key}')"></div>
                            </span>
                        </div>
                    ` : ''}
                    ${video.successRank !== null && video.successRank !== undefined ? `<div class="video-meta-item"><strong>Video Rank:</strong> <span style="font-weight: bold; color: ${getSuccessRankColor(video.successRank)};">#${video.successRank}</span></div>` : ''}
                    
                    <!-- Social Media Metrics Section -->
                    <div class="social-metrics-section" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
                        <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #333;">Social Media Metrics</h4>
                        ${video.igHashtags ? `<div class="video-meta-item"><strong>IG Hashtags:</strong> ${escapeHtml(video.igHashtags)}</div>` : ''}
                        ${video.tiktokHashtags ? `<div class="video-meta-item"><strong>TikTok Hashtags:</strong> ${escapeHtml(video.tiktokHashtags)}</div>` : ''}
                        ${video.igViews !== null ? `<div class="video-meta-item"><strong>IG Views:</strong> ${video.igViews.toLocaleString()}</div>` : ''}
                        ${video.igLikes !== null ? `<div class="video-meta-item"><strong>IG Likes:</strong> ${video.igLikes.toLocaleString()}</div>` : ''}
                        ${video.tiktokViews !== null ? `<div class="video-meta-item"><strong>TikTok Views:</strong> ${video.tiktokViews.toLocaleString()}</div>` : ''}
                        ${video.tiktokLikes !== null ? `<div class="video-meta-item"><strong>TikTok Likes:</strong> ${video.tiktokLikes.toLocaleString()}</div>` : ''}
                        ${video.metricsUpdatedAt ? `<div class="video-meta-item" style="font-size: 12px; color: #666; font-style: italic;"><strong>As of:</strong> ${formatDate(video.metricsUpdatedAt)}</div>` : ''}
                    </div>
                    
                    ${video.postedDate ? `<div class="video-meta-item"><strong>Posted:</strong> ${formatDate(video.postedDate)}</div>` : ''}
                </div>

                <div class="video-actions">
                    <button class="play-video-btn" data-s3key="${escapeHtml(video.s3Key)}">
                        ‚ñ∂ Play Video
                    </button>
                    <button class="edit-metrics-btn" data-s3key="${escapeHtml(video.s3Key)}">
                        ‚úèÔ∏è Edit Metrics
                    </button>
                    <button class="suggest-hashtags-btn" data-s3key="${escapeHtml(video.s3Key)}">
                        Suggest #s
                    </button>
                </div>
            </div>
        </div>
    `;

    // Add click handler for play button
    const playBtn = card.querySelector('.play-video-btn');
    playBtn.addEventListener('click', async () => {
        await playVideo(video.s3Key, playBtn);
    });

    // Add click handler for edit button
    const editBtn = card.querySelector('.edit-metrics-btn');
    editBtn.addEventListener('click', () => {
        openEditMetricsModal(video, card);
    });

    // Add click handler for suggest hashtags button
    const suggestBtn = card.querySelector('.suggest-hashtags-btn');
    suggestBtn.addEventListener('click', async () => {
        await openHashtagSuggestionsModal(video);
    });

    // Add click handler for delete button (X in top right)
    const deleteBtn = card.querySelector('.delete-video-btn-x');
    deleteBtn.addEventListener('click', async () => {
        await deleteVideo(video.s3Key, card, video.trackName, video.artistName);
    });

    // Load snapshot image if available
    const snapshotImg = card.querySelector('.video-snapshot');
    if (snapshotImg && video.snapshotKey) {
        loadVideoSnapshot(video.s3Key, snapshotImg);
    }

    return card;
}

async function loadVideoSnapshot(s3Key, imgElement) {
    try {
        const response = await fetch(`/api/videos/${encodeURIComponent(s3Key)}/snapshot`);
        
        if (!response.ok) {
            console.warn(`Failed to get snapshot URL: ${response.status}`);
            return;
        }

        const data = await response.json();
        imgElement.src = data.url;
        imgElement.style.display = 'block';
    } catch (err) {
        console.error('Error loading snapshot:', err);
    }
}

async function playVideo(s3Key, button) {
    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = 'Loading...';

    try {
        const response = await fetch(`/api/videos/${encodeURIComponent(s3Key)}/play`);
        
        if (!response.ok) {
            throw new Error(`Failed to get video URL: ${response.status}`);
        }

        const data = await response.json();
        
        // Open video in new window/tab
        window.open(data.url, '_blank');
        
    } catch (err) {
        alert(`Error loading video: ${err.message}`);
        console.error('Error playing video:', err);
    } finally {
        button.disabled = false;
        button.textContent = originalText;
    }
}

async function deleteVideo(s3Key, cardElement, trackName, artistName) {
    // Confirm deletion
    const confirmMessage = `Are you sure you want to delete "${trackName}" by ${artistName}? This will permanently delete the video and all related data.`;
    
    if (!confirm(confirmMessage)) {
        return;
    }

    const deleteBtn = cardElement.querySelector('.delete-video-btn-x');
    if (deleteBtn) {
        deleteBtn.disabled = true;
        deleteBtn.textContent = '...';
    }

    try {
        const response = await fetch(`/api/videos/${encodeURIComponent(s3Key)}`, {
            method: 'DELETE'
        });
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `Failed to delete video: ${response.status}`);
        }

        const data = await response.json();
        console.log('Video deleted:', data);
        
        // Remove the card from the DOM with a fade-out effect
        cardElement.style.transition = 'opacity 0.3s ease';
        cardElement.style.opacity = '0';
        
        setTimeout(() => {
            cardElement.remove();
            
            // Check if no videos left
            const videosContainer = document.getElementById('videosContainer');
            if (videosContainer.children.length === 0) {
                videosContainer.innerHTML = '<p style="text-align: center; padding: 40px; color: #666;">No videos uploaded yet.</p>';
            }
        }, 300);
        
    } catch (err) {
        alert(`Error deleting video: ${err.message}`);
        console.error('Error deleting video:', err);
        if (deleteBtn) {
            deleteBtn.disabled = false;
            deleteBtn.textContent = '√ó';
        }
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function formatDuration(seconds) {
    if (!seconds || seconds === 0) return 'N/A';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Store all videos for calculating top 20%
let allVideosForShockValue = [];

function getShockValueColor(score) {
    // All black by default, top 20% will be green
    return '#000000'; // Black
}

function getShockValueColorWithTop20(score, allVideos) {
    if (!allVideos || allVideos.length === 0) return '#000000';
    
    // Filter videos with shock values
    const videosWithShock = allVideos.filter(v => v.shockValue !== null && v.shockValue !== undefined);
    if (videosWithShock.length === 0) return '#000000';
    
    // Sort by shock value descending
    const sorted = [...videosWithShock].sort((a, b) => b.shockValue - a.shockValue);
    
    // Calculate top 20% threshold
    const top20Count = Math.max(1, Math.ceil(sorted.length * 0.2));
    const top20Threshold = sorted[top20Count - 1].shockValue;
    
    // If this score is in top 20%, make it green
    if (score >= top20Threshold) {
        return '#28a745'; // Green - top 20%
    }
    
    return '#000000'; // Black - all others
}

function getSuccessScoreColor(score) {
    if (score >= 70) return '#28a745'; // Green - high success
    if (score >= 40) return '#ffc107'; // Yellow - medium success
    return '#dc3545'; // Red - low success
}

function getSuccessRankColor(rank) {
    if (rank <= 3) return '#28a745'; // Green - top 3
    if (rank <= 6) return '#ffc107'; // Yellow - top 6
    return '#6c757d'; // Gray - lower ranks
}

function formatDate(dateString) {
    if (!dateString) return 'N/A';
    // If it's already in YYYY-MM-DD format, use it directly
    if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
        const [year, month, day] = dateString.split('-');
        return `${month}/${day}/${year}`;
    }
    // Otherwise, parse as date and format
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: '2-digit', 
        day: '2-digit'
    });
}

// Edit Metrics Modal
function openEditMetricsModal(video, cardElement) {
    // Create modal overlay
    const modal = document.createElement('div');
    modal.className = 'edit-metrics-modal';
    modal.innerHTML = `
        <div class="edit-metrics-modal-content">
            <div class="edit-metrics-modal-header">
                <h2>Edit Metrics - ${escapeHtml(video.trackName)}</h2>
                <button class="close-modal-btn">&times;</button>
            </div>
            <form id="editMetricsForm" class="edit-metrics-form">
                <div class="form-group">
                    <label>IG Hashtags</label>
                    <input type="text" id="edit-ig-hashtags" value="${escapeHtml(video.igHashtags || '')}" placeholder="e.g., #drumming #music">
                </div>
                <div class="form-group">
                    <label>TikTok Hashtags</label>
                    <input type="text" id="edit-tiktok-hashtags" value="${escapeHtml(video.tiktokHashtags || '')}" placeholder="e.g., #drumming #music">
                </div>
                <div class="form-group">
                    <label>IG Views</label>
                    <input type="number" id="edit-ig-views" value="${video.igViews || ''}" placeholder="0" min="0">
                </div>
                <div class="form-group">
                    <label>IG Likes</label>
                    <input type="number" id="edit-ig-likes" value="${video.igLikes || ''}" placeholder="0" min="0">
                </div>
                <div class="form-group">
                    <label>TikTok Views</label>
                    <input type="number" id="edit-tiktok-views" value="${video.tiktokViews || ''}" placeholder="0" min="0">
                </div>
                <div class="form-group">
                    <label>TikTok Likes</label>
                    <input type="number" id="edit-tiktok-likes" value="${video.tiktokLikes || ''}" placeholder="0" min="0">
                </div>
                <div class="form-group">
                    <label>Posted Date</label>
                    <input type="date" id="edit-posted-date" value="${video.postedDate ? (video.postedDate.includes('T') ? new Date(video.postedDate).toISOString().split('T')[0] : video.postedDate.split('T')[0]) : ''}">
                </div>
                <div class="form-actions">
                    <button type="button" class="cancel-btn">Cancel</button>
                    <button type="submit" class="save-btn">Save</button>
                </div>
            </form>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Close modal handlers
    const closeBtn = modal.querySelector('.close-modal-btn');
    const cancelBtn = modal.querySelector('.cancel-btn');
    const closeModal = () => {
        document.body.removeChild(modal);
    };
    
    closeBtn.addEventListener('click', closeModal);
    cancelBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    
    // Form submission
    const form = modal.querySelector('#editMetricsForm');
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const postedDateValue = document.getElementById('edit-posted-date').value;
        const metrics = {
            igHashtags: document.getElementById('edit-ig-hashtags').value.trim() || null,
            tiktokHashtags: document.getElementById('edit-tiktok-hashtags').value.trim() || null,
            igViews: document.getElementById('edit-ig-views').value ? parseInt(document.getElementById('edit-ig-views').value) : null,
            igLikes: document.getElementById('edit-ig-likes').value ? parseInt(document.getElementById('edit-ig-likes').value) : null,
            tiktokViews: document.getElementById('edit-tiktok-views').value ? parseInt(document.getElementById('edit-tiktok-views').value) : null,
            tiktokLikes: document.getElementById('edit-tiktok-likes').value ? parseInt(document.getElementById('edit-tiktok-likes').value) : null,
            postedDate: postedDateValue || null, // Store as YYYY-MM-DD string to avoid timezone issues
        };
        
        try {
            const response = await fetch(`/api/videos/${encodeURIComponent(video.s3Key)}/metrics`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(metrics)
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Failed to update metrics: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('Metrics updated:', data);
            
            // Reload videos to show updated data
            closeModal();
            loadVideos();
            
        } catch (err) {
            alert(`Error updating metrics: ${err.message}`);
            console.error('Error updating metrics:', err);
        }
    });
}

// Hashtag Suggestions Modal
async function openHashtagSuggestionsModal(video) {
    // Show loading state
    const modal = document.createElement('div');
    modal.className = 'hashtag-suggestions-modal';
    modal.innerHTML = `
        <div class="hashtag-suggestions-modal-content">
            <div class="hashtag-suggestions-modal-header">
                <h2>Hashtag Suggestions - ${escapeHtml(video.trackName)}</h2>
                <button class="close-modal-btn">&times;</button>
            </div>
            <div class="hashtag-suggestions-loading">
                <p>Analyzing historical data and generating recommendations...</p>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Close modal handler
    const closeBtn = modal.querySelector('.close-modal-btn');
    const closeModal = () => {
        document.body.removeChild(modal);
    };
    
    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    
    try {
        // Fetch hashtag suggestions from backend
        const response = await fetch(`/api/videos/${encodeURIComponent(video.s3Key)}/hashtag-suggestions`);
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `Failed to get suggestions: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Calculate recommended counts based on total suggestions
        // Instagram: top 8-10 recommended out of 15 (optimal is 7-12)
        const igRecommendedCount = Math.min(Math.max(8, Math.floor(data.instagram.length * 0.6)), 10);
        // TikTok: top 5-7 recommended out of 15 (optimal is 3-6)
        const tiktokRecommendedCount = Math.min(Math.max(5, Math.floor(data.tiktok.length * 0.4)), 7);
        
        // Update modal with suggestions
        const loadingDiv = modal.querySelector('.hashtag-suggestions-loading');
        loadingDiv.innerHTML = `
            <div class="hashtag-suggestions-content">
                <div class="hashtag-platform-section">
                    <h3>üì∑ Instagram Hashtags</h3>
                    <div class="hashtag-list">
                        ${data.instagram.map((tag, index) => `
                            <span class="hashtag-tag ${index < igRecommendedCount ? 'hashtag-top' : ''}" data-hashtag="${escapeHtml(tag)}">
                                ${escapeHtml(tag)}
                            </span>
                        `).join('')}
                    </div>
                    <div class="hashtag-buttons-group">
                        <button class="copy-hashtags-btn copy-recommended-btn" data-platform="instagram" data-type="recommended" data-count="${igRecommendedCount}">Copy Recommended (Top ${igRecommendedCount})</button>
                        <button class="copy-hashtags-btn copy-all-btn" data-platform="instagram" data-type="all">Copy All (${data.instagram.length})</button>
                    </div>
                </div>
                
                <div class="hashtag-platform-section">
                    <h3>üéµ TikTok Hashtags</h3>
                    <div class="hashtag-list">
                        ${data.tiktok.map((tag, index) => `
                            <span class="hashtag-tag ${index < tiktokRecommendedCount ? 'hashtag-top' : ''}" data-hashtag="${escapeHtml(tag)}">
                                ${escapeHtml(tag)}
                            </span>
                        `).join('')}
                    </div>
                    <div class="hashtag-buttons-group">
                        <button class="copy-hashtags-btn copy-recommended-btn" data-platform="tiktok" data-type="recommended" data-count="${tiktokRecommendedCount}">Copy Recommended (Top ${tiktokRecommendedCount})</button>
                        <button class="copy-hashtags-btn copy-all-btn" data-platform="tiktok" data-type="all">Copy All (${data.tiktok.length})</button>
                    </div>
                </div>
                
                <div class="hashtag-suggestions-footer">
                    <p class="hashtag-note">üí° Top ${igRecommendedCount} Instagram and top ${tiktokRecommendedCount} TikTok recommendations are highlighted. Click any hashtag to copy it individually.</p>
                </div>
            </div>
        `;
        
        // Add click handlers for individual hashtags
        modal.querySelectorAll('.hashtag-tag').forEach(tagEl => {
            tagEl.addEventListener('click', () => {
                const hashtag = tagEl.getAttribute('data-hashtag');
                navigator.clipboard.writeText(hashtag).then(() => {
                    tagEl.classList.add('hashtag-copied');
                    setTimeout(() => tagEl.classList.remove('hashtag-copied'), 1000);
                });
            });
        });
        
        // Add copy buttons
        modal.querySelectorAll('.copy-hashtags-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const platform = btn.getAttribute('data-platform');
                const type = btn.getAttribute('data-type'); // 'recommended' or 'all'
                const allHashtags = platform === 'instagram' ? data.instagram : data.tiktok;
                
                // Get hashtags based on type
                let hashtags;
                if (type === 'recommended') {
                    // Top N recommended hashtags (dynamic count from data attribute)
                    const recommendedCount = parseInt(btn.getAttribute('data-count')) || 
                        (platform === 'instagram' ? igRecommendedCount : tiktokRecommendedCount);
                    hashtags = allHashtags.slice(0, recommendedCount);
                } else {
                    // All hashtags
                    hashtags = allHashtags;
                }
                
                const text = hashtags.join(' ');
                navigator.clipboard.writeText(text).then(() => {
                    const originalText = btn.textContent;
                    btn.textContent = '‚úì Copied!';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000);
                });
            });
        });
        
    } catch (err) {
        const loadingDiv = modal.querySelector('.hashtag-suggestions-loading');
        loadingDiv.innerHTML = `
            <div class="hashtag-suggestions-error">
                <p>Error loading suggestions: ${escapeHtml(err.message)}</p>
                <button class="retry-btn" onclick="location.reload()">Retry</button>
            </div>
        `;
        console.error('Error fetching hashtag suggestions:', err);
    }
}

// Hover dropdown functions for shock value and success score
let scoreDropdownTimeout = null;

function showShockValueDropdown(id, shockValue, tempoSpikes, volumeSpikes, unusualPatterns) {
    // Clear any pending hide timeout
    if (scoreDropdownTimeout) {
        clearTimeout(scoreDropdownTimeout);
        scoreDropdownTimeout = null;
    }
    
    const dropdown = document.getElementById(`shock-dropdown-${id}`);
    if (!dropdown) return;
    
    // Find the trigger element - if dropdown is already in body, find it via the original parent or by searching
    let trigger = null;
    let videoCard = null;
    
    // Try to find trigger using closest (works if dropdown is still in original location)
    if (dropdown.parentElement && dropdown.parentElement !== document.body) {
        trigger = dropdown.closest('.hoverable-score-container');
        videoCard = trigger ? trigger.closest('.video-card') : null;
    }
    
    // If not found, search for it by the dropdown ID pattern
    if (!trigger || !videoCard) {
        // The id format is 'shock-dropdown-shock-${s3Key}', so we extract the s3Key
        const s3Key = id.replace('shock-', '');
        // Try multiple search strategies
        const clickableScore = document.querySelector(`span.clickable-score[onmouseenter*="'shock-${s3Key}'"]`) ||
                              document.querySelector(`.clickable-score[onmouseenter*="${s3Key}"]`);
        if (clickableScore) {
            trigger = clickableScore.closest('.hoverable-score-container');
            videoCard = trigger ? trigger.closest('.video-card') : null;
        }
    }
    
    // Close all other score dropdowns
    document.querySelectorAll('.score-dropdown').forEach(dd => {
        if (dd.id !== `shock-dropdown-${id}` && dd.id !== `success-dropdown-${id}`) {
            dd.style.display = 'none';
        }
    });
    
    // Handle string 'null' values passed from HTML
    const tempoSpikesValue = (tempoSpikes === 'null' || tempoSpikes === null || tempoSpikes === undefined) ? null : parseFloat(tempoSpikes);
    const volumeSpikesValue = (volumeSpikes === 'null' || volumeSpikes === null || volumeSpikes === undefined) ? null : parseFloat(volumeSpikes);
    const unusualPatternsValue = (unusualPatterns === 'null' || unusualPatterns === null || unusualPatterns === undefined) ? null : parseFloat(unusualPatterns);
    
    const hasComponents = tempoSpikesValue !== null || volumeSpikesValue !== null || unusualPatternsValue !== null;
    
    // Set content first so we can measure actual width
    if (hasComponents) {
        dropdown.innerHTML = `
            <div style="margin-bottom: 10px; color: #666; font-size: 12px;">
                <strong>Shock Value Breakdown</strong>
            </div>
            <div style="margin-top: 15px;">
                <div style="margin-bottom: 12px;">
                    <strong style="color: #333;">Tempo Spikes (Fills):</strong>
                    <span style="float: right; font-weight: 600;">${tempoSpikesValue !== null ? tempoSpikesValue.toFixed(1) : 'N/A'}/100</span>
                </div>
                <div style="margin-bottom: 12px;">
                    <strong style="color: #333;">Volume Spikes (Accents):</strong>
                    <span style="float: right; font-weight: 600;">${volumeSpikesValue !== null ? volumeSpikesValue.toFixed(1) : 'N/A'}/100</span>
                </div>
                <div style="margin-bottom: 12px;">
                    <strong style="color: #333;">Unusual Patterns:</strong>
                    <span style="float: right; font-weight: 600;">${unusualPatternsValue !== null ? unusualPatternsValue.toFixed(1) : 'N/A'}/100</span>
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 2px solid #e9ecef;">
                    <strong style="color: #333; font-size: 16px;">Total Shock Value:</strong>
                    <span style="float: right; font-weight: 700; font-size: 16px; color: ${getShockValueColorWithTop20(shockValue, allVideosForShockValue)};">${shockValue}/100</span>
                </div>
                <div style="margin-top: 10px; font-size: 11px; color: #666; font-style: italic;">
                    Weighted combination of the three components above
                </div>
            </div>
        `;
    } else {
        dropdown.innerHTML = '<p>No detailed shock value components available for this video.</p>';
    }
    
    // Move dropdown to body FIRST to avoid parent container clipping issues
    // This must be done before getting cardRect/triggerRect
    if (dropdown.parentElement !== document.body) {
        document.body.appendChild(dropdown);
    }
    
    // Reset all positioning styles to ensure clean state
    dropdown.style.display = 'block';
    dropdown.style.position = 'fixed';
    dropdown.style.visibility = 'hidden';
    dropdown.style.top = '0px';
    dropdown.style.left = '-9999px';
    dropdown.style.zIndex = '2147483647'; // Set z-index early
    dropdown.style.transform = 'translateZ(0)'; // Force new stacking context
    dropdown.style.right = 'auto'; // Clear any right positioning
    dropdown.style.bottom = 'auto'; // Clear any bottom positioning
    
    // Use offsetWidth which works even when visibility is hidden
    // Force a reflow to ensure dimensions are calculated
    void dropdown.offsetWidth;
    
    // Now position it properly using actual measurements
    if (videoCard && trigger) {
        // Get bounding rects AFTER moving to body (these are still valid)
        const cardRect = videoCard.getBoundingClientRect();
        const triggerRect = trigger.getBoundingClientRect();
        
        const viewportWidth = window.innerWidth;
        const padding = 10; // Padding from viewport edge
        
        // Get actual dropdown width using offsetWidth (works even when hidden)
        const dropdownWidth = dropdown.offsetWidth || 320; // fallback to min-width
        
        // Start with left edge aligned to card
        let leftPosition = cardRect.left;
        
        // Check if dropdown would overflow the right edge of viewport
        if (leftPosition + dropdownWidth > viewportWidth - padding) {
            // Adjust to keep within viewport
            leftPosition = Math.max(padding, viewportWidth - dropdownWidth - padding);
        }
        
        // Ensure we don't go off the left edge
        if (leftPosition < padding) {
            leftPosition = padding;
        }
        
        // Apply final position and make visible
        dropdown.style.left = leftPosition + 'px';
        dropdown.style.top = (triggerRect.bottom + 4) + 'px';
        dropdown.style.visibility = 'visible';
    } else {
        // Fallback if card/trigger not found
        dropdown.style.visibility = 'visible';
    }
}

function hideShockValueDropdown(id) {
    // Small delay to allow moving mouse to dropdown
    scoreDropdownTimeout = setTimeout(() => {
        const dropdown = document.getElementById(`shock-dropdown-${id}`);
        if (dropdown) {
            dropdown.style.display = 'none';
            dropdown.style.visibility = 'hidden';
        }
        scoreDropdownTimeout = null;
    }, 200);
}

function showSuccessScoreDropdown(id, igViews, igLikes, tiktokViews, tiktokLikes, successScore) {
    // Clear any pending hide timeout
    if (scoreDropdownTimeout) {
        clearTimeout(scoreDropdownTimeout);
        scoreDropdownTimeout = null;
    }
    
    const dropdown = document.getElementById(`success-dropdown-${id}`);
    if (!dropdown) return;
    
    // Find the trigger element - if dropdown is already in body, find it via the original parent or by searching
    let trigger = null;
    let videoCard = null;
    
    // Try to find trigger using closest (works if dropdown is still in original location)
    if (dropdown.parentElement && dropdown.parentElement !== document.body) {
        trigger = dropdown.closest('.hoverable-score-container');
        videoCard = trigger ? trigger.closest('.video-card') : null;
    }
    
    // If not found, search for it by the dropdown ID pattern
    if (!trigger || !videoCard) {
        // The id format is 'success-dropdown-success-${s3Key}', so we extract the s3Key
        const s3Key = id.replace('success-', '');
        // Try multiple search strategies
        const clickableScore = document.querySelector(`span.clickable-score[onmouseenter*="'success-${s3Key}'"]`) ||
                              document.querySelector(`.clickable-score[onmouseenter*="${s3Key}"]`);
        if (clickableScore) {
            trigger = clickableScore.closest('.hoverable-score-container');
            videoCard = trigger ? trigger.closest('.video-card') : null;
        }
    }
    
    // Close all other score dropdowns
    document.querySelectorAll('.score-dropdown').forEach(dd => {
        if (dd.id !== `success-dropdown-${id}` && dd.id !== `shock-dropdown-${id}`) {
            dd.style.display = 'none';
        }
    });
    
    // Calculate medians for normalization display
    const igViewsValues = allVideosForShockValue.filter(v => v.igViews > 0).map(v => v.igViews);
    const igLikesValues = allVideosForShockValue.filter(v => v.igLikes !== null && v.igLikes >= 0).map(v => v.igLikes);
    const tiktokViewsValues = allVideosForShockValue.filter(v => v.tiktokViews > 0).map(v => v.tiktokViews);
    const tiktokLikesValues = allVideosForShockValue.filter(v => v.tiktokLikes !== null && v.tiktokLikes >= 0).map(v => v.tiktokLikes);
    
    const calculateMedian = (values) => {
        if (values.length === 0) return 0;
        const sorted = [...values].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0
            ? (sorted[mid - 1] + sorted[mid]) / 2
            : sorted[mid];
    };
    
    const igViewsMedian = calculateMedian(igViewsValues);
    const igLikesMedian = calculateMedian(igLikesValues);
    const tiktokViewsMedian = calculateMedian(tiktokViewsValues);
    const tiktokLikesMedian = calculateMedian(tiktokLikesValues);
    
    // Calculate engagement rate medians
    const igEngagementRates = allVideosForShockValue
        .filter(v => v.igViews > 0 && v.igLikes !== null && v.igLikes >= 0)
        .map(v => v.igLikes / v.igViews);
    const tiktokEngagementRates = allVideosForShockValue
        .filter(v => v.tiktokViews > 0 && v.tiktokLikes !== null && v.tiktokLikes >= 0)
        .map(v => v.tiktokLikes / v.tiktokViews);
    
    const igEngagementMedian = calculateMedian(igEngagementRates);
    const tiktokEngagementMedian = calculateMedian(tiktokEngagementRates);
    
    // Calculate component scores (equally weighted, normalized to median, capped at 2x)
    const metrics = [];
    let metricLabels = [];
    
    if (igViews > 0 && igViewsMedian > 0) {
        const ratio = Math.min(igViews / igViewsMedian, 2);
        metrics.push(ratio);
        metricLabels.push({ name: 'IG Views', ratio: ratio, value: igViews, median: igViewsMedian });
    }
    if (igLikes !== null && igLikes !== undefined && igLikes >= 0 && igLikesMedian > 0) {
        const ratio = Math.min(igLikes / igLikesMedian, 2);
        metrics.push(ratio);
        metricLabels.push({ name: 'IG Likes', ratio: ratio, value: igLikes, median: igLikesMedian });
    }
    if (igViews > 0 && igLikes !== null && igLikes !== undefined && igLikes >= 0 && igEngagementMedian > 0) {
        const engagementRate = igLikes / igViews;
        const ratio = Math.min(engagementRate / igEngagementMedian, 2);
        metrics.push(ratio);
        metricLabels.push({ name: 'IG Engagement', ratio: ratio, value: engagementRate, median: igEngagementMedian });
    }
    if (tiktokViews > 0 && tiktokViewsMedian > 0) {
        const ratio = Math.min(tiktokViews / tiktokViewsMedian, 2);
        metrics.push(ratio);
        metricLabels.push({ name: 'TikTok Views', ratio: ratio, value: tiktokViews, median: tiktokViewsMedian });
    }
    if (tiktokLikes !== null && tiktokLikes !== undefined && tiktokLikes >= 0 && tiktokLikesMedian > 0) {
        const ratio = Math.min(tiktokLikes / tiktokLikesMedian, 2);
        metrics.push(ratio);
        metricLabels.push({ name: 'TikTok Likes', ratio: ratio, value: tiktokLikes, median: tiktokLikesMedian });
    }
    if (tiktokViews > 0 && tiktokLikes !== null && tiktokLikes !== undefined && tiktokLikes >= 0 && tiktokEngagementMedian > 0) {
        const engagementRate = tiktokLikes / tiktokViews;
        const ratio = Math.min(engagementRate / tiktokEngagementMedian, 2);
        metrics.push(ratio);
        metricLabels.push({ name: 'TikTok Engagement', ratio: ratio, value: engagementRate, median: tiktokEngagementMedian });
    }
    
    // Calculate average ratio for display
    const avgRatio = metrics.length > 0 
        ? metrics.reduce((sum, ratio) => sum + ratio, 0) / metrics.length 
        : 0;
    
    dropdown.innerHTML = `
        <div style="margin-bottom: 10px; color: #666; font-size: 12px;">
            <strong>Success Score Breakdown</strong>
        </div>
        <div style="margin-top: 15px;">
            ${metricLabels.map(metric => {
                const isEngagement = metric.name.includes('Engagement');
                const displayValue = isEngagement 
                    ? (metric.value * 100).toFixed(2) + '%'
                    : metric.value.toLocaleString();
                const displayMedian = isEngagement 
                    ? (metric.median * 100).toFixed(2) + '%'
                    : metric.median.toLocaleString();
                const ratioPercent = (metric.ratio * 100).toFixed(1);
                
                return `
                    <div style="margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span><strong>${metric.name}:</strong></span>
                            <span style="font-weight: 600;">${ratioPercent}% of median</span>
                        </div>
                        <div style="font-size: 11px; color: #666; margin-left: 10px;">
                            ${displayValue} (median: ${displayMedian})
                        </div>
                    </div>
                `;
            }).join('')}
            <div style="margin-top: 15px; padding-top: 15px; border-top: 2px solid #e9ecef;">
                <div style="margin-bottom: 8px;">
                    <strong style="color: #333; font-size: 14px;">Average Ratio:</strong>
                    <span style="float: right; font-weight: 600;">${(avgRatio * 100).toFixed(1)}%</span>
                </div>
                <div style="margin-bottom: 8px;">
                    <strong style="color: #333; font-size: 16px;">Total Success Score:</strong>
                    <span style="float: right; font-weight: 700; font-size: 16px; color: ${getSuccessScoreColor(successScore)};">${successScore}/100</span>
                </div>
            </div>
            <div style="margin-top: 10px; font-size: 11px; color: #666; font-style: italic;">
                Equally weighted average of ${metrics.length} metric${metrics.length !== 1 ? 's' : ''}. Score = (avg ratio / 2.0) √ó 100
            </div>
        </div>
    `;
    
    // Reset all positioning styles to ensure clean state
    dropdown.style.display = 'block';
    dropdown.style.position = 'fixed';
    dropdown.style.visibility = 'hidden';
    dropdown.style.top = '0px';
    dropdown.style.left = '-9999px';
    dropdown.style.zIndex = '2147483647'; // Set z-index early
    dropdown.style.transform = 'translateZ(0)'; // Force new stacking context
    dropdown.style.right = 'auto'; // Clear any right positioning
    dropdown.style.bottom = 'auto'; // Clear any bottom positioning
    
    // Use offsetWidth which works even when visibility is hidden
    // Force a reflow to ensure dimensions are calculated
    void dropdown.offsetWidth;
    
    // Now position it properly using actual measurements
    if (videoCard && trigger) {
        const cardRect = videoCard.getBoundingClientRect();
        const triggerRect = trigger.getBoundingClientRect();
        
        const viewportWidth = window.innerWidth;
        const padding = 10; // Padding from viewport edge
        
        // Get actual dropdown width using offsetWidth (works even when hidden)
        const dropdownWidth = dropdown.offsetWidth || 320; // fallback to min-width
        
        // Start with left edge aligned to card
        let leftPosition = cardRect.left;
        
        // Check if dropdown would overflow the right edge of viewport
        if (leftPosition + dropdownWidth > viewportWidth - padding) {
            // Adjust to keep within viewport
            leftPosition = Math.max(padding, viewportWidth - dropdownWidth - padding);
        }
        
        // Ensure we don't go off the left edge
        if (leftPosition < padding) {
            leftPosition = padding;
        }
        
        // Apply final position and make visible
        dropdown.style.left = leftPosition + 'px';
        dropdown.style.top = (triggerRect.bottom + 4) + 'px';
        dropdown.style.zIndex = '2147483647'; // Maximum z-index
        dropdown.style.visibility = 'visible';
        dropdown.style.transform = 'translateZ(0)'; // Force new stacking context
    } else {
        dropdown.style.visibility = 'visible';
        dropdown.style.zIndex = '2147483647'; // Maximum z-index
        dropdown.style.transform = 'translateZ(0)'; // Force new stacking context
    }
}

function hideSuccessScoreDropdown(id) {
    // Small delay to allow moving mouse to dropdown
    scoreDropdownTimeout = setTimeout(() => {
        const dropdown = document.getElementById(`success-dropdown-${id}`);
        if (dropdown) {
            dropdown.style.display = 'none';
            dropdown.style.visibility = 'hidden';
        }
        scoreDropdownTimeout = null;
    }, 200);
}

function clearScoreDropdownTimeout() {
    if (scoreDropdownTimeout) {
        clearTimeout(scoreDropdownTimeout);
        scoreDropdownTimeout = null;
    }
}

function createScorePopupElements() {
    const overlay = document.createElement('div');
    overlay.id = 'score-popup-overlay';
    overlay.className = 'popup-overlay';
    overlay.onclick = closeScorePopup;
    
    const popup = document.createElement('div');
    popup.id = 'score-popup';
    popup.className = 'score-popup';
    popup.onclick = (e) => e.stopPropagation();
    
    popup.innerHTML = `
        <div class="score-popup-header">
            <h3>Score Breakdown</h3>
            <button class="score-popup-close" onclick="closeScorePopup()">√ó</button>
        </div>
        <div class="score-popup-content"></div>
    `;
    
    document.body.appendChild(overlay);
    document.body.appendChild(popup);
    
    return overlay;
}

function closeScorePopup() {
    const overlay = document.getElementById('score-popup-overlay');
    const popup = document.getElementById('score-popup');
    if (overlay) overlay.classList.remove('show');
    if (popup) popup.classList.remove('show');
}

// Load videos when page loads
loadVideos();
</script>

<style>
.popup-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 9999;
}

.popup-overlay.show {
    display: block;
}

.score-popup {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border: 2px solid #333;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    z-index: 10000;
    max-width: 500px;
    max-height: 70vh;
    overflow-y: auto;
}

.score-popup.show {
    display: block;
}

.score-popup-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 2px solid #e9ecef;
}

.score-popup-header h3 {
    margin: 0;
    font-size: 18px;
    color: #333;
}

.score-popup-close {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #666;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.score-popup-close:hover {
    color: #333;
}

.score-popup-content {
    font-size: 14px;
}

.clickable-score:hover {
    opacity: 0.8;
}

.score-dropdown {
    z-index: 2147483647 !important; /* Maximum z-index value */
    position: fixed !important;
    pointer-events: auto !important;
    transform: translateZ(0) !important; /* Force hardware acceleration and new stacking context */
}

.hoverable-score-container {
    position: relative;
}
</style>

</body>
</html>

